# -*- coding: utf-8 -*-
"""Exoplanet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Fl6kgufQfGqah7tPQmFeDDtEmRStpmJZ
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math 
import seaborn as sns

df = pd.read_csv("C:/Users/hp/Desktop/me/Projects/Space/Case Study-1/Exoplanet Data-NSSC_20_CS1.csv",header=0)
df.head(15)

#Q(b)(a)
print(df['detection_type'].value_counts())

plt.style.use('default')

d=df['detection_type'].value_counts() #This function return a Series containing counts of unique values.
d.plot.pie(figsize=(12, 6),autopct='%1.1f%%',wedgeprops={"edgecolor":"black",'linewidth': 0.6}) #To Plot Pie Chart
plt.legend(title='Detection Type',loc="best")
plt.ylabel('Detection Type',fontsize=15)
plt.axis("equal")
plt.suptitle('Analysis For Commonly Used Detection Methods For Exoplanets', size=16, y=1); 
plt.show()
plt.savefig('fig1.jpeg',dpi=900)

plt.figure(figsize=(9,9))
total=0
labels = df['detection_type'].value_counts().index.tolist()
sizes = df['detection_type'].value_counts().values.tolist()
for s in sizes:
  total += s
print(total)

sns.barplot(labels, sizes)  # Using Barplot
plt.xticks(rotation=0)
loc , Labels = plt.xticks()

for x1,y1 in zip(loc, sizes):
    a=(int(y1)/total)*100
    label = "{:}%".format(a)
    plt.annotate(label,(x1,y1), textcoords="offset points",xytext=(0,5),ha='left')
plt.title('Detection Type',fontsize=12)
plt.show()

#Groupby 'detection_type' and return the mean of only particular column in the group.
print(df.groupby('detection_type')['mass(Jupiter mass)'].mean())
print("\n------------------------\n",df.groupby('detection_type')['radius(Earth radius)'].mean())
print("\n------------------------\n",df.groupby('detection_type')['period(Earth years)'].mean())
print("\n------------------------\n",df.groupby('detection_type')['star_mass(Solar Mass)'].mean())

#Groupby "detection_type" and  return the mean of the remaining columns in each group.
df.groupby('detection_type').mean()

exo_1=df.loc[df.target_name=="HD 10697 b"]
print("Host Star =",exo_1.at[12,"star_name"])
print("--------------------------------------")
exo_1

#Q(a)(d)
m1=exo_1.at[12,"mass(Jupiter mass)"] # Mass of the exoplanet
m2=exo_1.at[12,"star_mass(Solar Mass)"] # Mass of the star
M=m1+m2

a=exo_1.at[12,"semi_major_axis(AU)"]
e=exo_1.at[12,"eccentricity"]
v=exo_1.at[12,"inclination(Degree)"]

#thetha = 69.0 degrees = 1.20428 radians
r1_1=a*(1-pow(e,2))/(1+e*math.cos(1.20428))
print("r (distance between host star and exoplanet for given Î¸)= ",r1_1)

rmin=a*(1-pow(e,2))/(1+e)
rmax=a*(1-pow(e,2))/(1-e)
print("r_min (min distance between host star and exoplanet)= ",rmin)
print("r_max (max distance between host star and exoplanet)= ",rmax)

velmin=math.sqrt(M*((2/rmax)-(1/a)))
print("v_min= ",velmin)
velmax=math.sqrt(M*((2/rmin)-(1/a)))
print("v_max= ",velmax)

a=df["semi_major_axis(AU)"]
e=df["eccentricity"]
v=df["inclination(Degree)"]

rmin=pd.DataFrame(a*(1-pow(e,2))/(1+e),columns=['r_min'])
rmax=pd.DataFrame(a*(1-pow(e,2))/(1-e),columns=['r_max'])

r_=pd.merge(rmin,rmax,left_index=True, right_index=True)
r_all=pd.merge(df['target_name'],r_,left_index=True, right_index=True)
print(r_all)

#Q(d)(c)
L=df['star_lum(Solar Luminosity)']
R_max=pd.DataFrame(pow(L/(4*3.1415*0.01),1/2))
R_min=pd.DataFrame(pow(L/(4*3.1415*0.32),1/2))
R_=pd.merge(R_min,R_max,left_index=True, right_index=True)
R_.columns = ["R_min","R_max"]

# Determine which of the exoplanets in the given dataset fall into the habitable zone:-
df2=pd.merge(r_all,R_,left_index=True, right_index=True)
new = df2[((df2.r_min > df2.R_min) & (df2.r_min < df2.R_max)) | ((df2.r_max > df2.R_min) & (df2.r_max < df2.R_max))]
new
